# A hacky attempt at "gasless" minting

See [this](https://www.freecodecamp.org/news/how-to-make-an-nft-and-render-on-opensea-marketplace/) tutorial on NFTs for instructions on how to set up `brownie` and to learn about making NFTs in general. Then if you really want to you can test this locally as follows

`brownie run lazy_mint.py --network development`

This builds on the implementation from OpenZepplin for regular NFTs.

**PLEASE DO NOT USE THIS IN PRODUCTION OR RELY ON THIS IN ANY WAY**

- This was purely a learning exercise to figure out how "gasless" minting might be done and to understand how to do various things like signature verfication
- It is probably wrong in many respects
- I have yet to handle the visibilty of different functions many of which I made public for easy debugging

- I thought that would only want read functions to be available for sake of the wallet since the whole point is that you don't want any transactions until you transfer.

- What you could do though is akin to how `SafeTransfer` is done now so that verification plus minting happens before the rest of the function is executed but not entirely sure what would be the motivation for making use of any of the other functions.

- It would be a way though to comply with EIP-721 where it states

> The contract MUST allow multiple operators per owner.

- However it does not say it must do so in all circumstances. 

- I have left out some of the read only functions as it is not obvious how to make them work.

- I have not investigated off-chain data for example using IPFS for instance to store token ids or maintain a counter for lazily minted ids

- None of this is by any means deployable

- I have not tested the functions beyond making sure they don't break for very limited and obvious inputs nor have I determined if the code is properly complied with EIP-721.

- This uses EIP 191 standard for hashed messages for signature verification whilst it seems that EIP 712 is to be preferred.

### Identifying ownership

The only functionality that is likely to really matter context of gasless minting is transfer. For this there is signature-based ownership verification by requiring the owner to sign the token id hash. The contract just XOR's the token with the hashed address to get the signed message hash and also receives the signature and using the two of these can verify if the sender is the owner.

Right now the hacky way in which read only functions work is via a kind of "lazy verification". The token id is generated by duplicating a token hex string with 16 elements. This is signed with the address and hashed for signature verification. Then the initial token id is XOR-d with a hash of the address to get the final token id. For "lazy verification" you just XOR the token id with the address then confirm that the token id consists of two identical halves whilst the hashed XOR-d version did not (you could generate a new different token ids and get another hash in the rare event that the two halves of the hashed value were the same). 

This is in any way not meant to be secure and was more of an exercise in coming up with a means of determining whether the sender was the owner based on `tokenId` and the sender's address as well (as the size constraints e.g. some functions only accept a single uint256 input precluding signatures as well methods available in solidity). A message integrity mechanism would might be better. The token is only "visible" to the owner. It could potentially show up in a wallet depending on how the wallet determines ownership and that was the main reason I thought of trying to modify the read-only functions.



 

